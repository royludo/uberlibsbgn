package org.sbgn.uberlibsbgn;

import org.sbgn.bindings.Sbgn;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

public class IdManager {

    private IdStrategy strategy;

    private Set<String> idSet;

    private long idCounter = 1;

    final Logger logger = LoggerFactory.getLogger(IdManager.class);

    public IdManager(IdStrategy strategy) {
        this.strategy = strategy;
        this.idSet = new HashSet<>();
    }

    public synchronized String getNewId() {
        String id;
        switch (this.strategy) {
            case UUID:
                id = this.checkAndAddId(UUID.randomUUID().toString());
                break;
            case SIMPLE_INCREMENT:
                id = this.checkAndAddIncrementalId(createIncrementalID());
                break;
            default:
                throw new IllegalStateException("Unknown id management strategy");
        }


        return id;
    }

    public synchronized String useCustomId(String id) {
        return this.checkAndAddId(id);
    }

    public enum IdStrategy {
        UUID, SIMPLE_INCREMENT;
    }

    private synchronized String checkAndAddId(String id) {
        String definitiveId = prependUnderscoreIfNotAlready(id);

        if(this.idSet.contains(definitiveId)) {
            throw new IllegalArgumentException("Trying to use non unique id. Id: " + definitiveId + " was already present.");
        }
        this.idSet.add(definitiveId);

        return definitiveId;
    }

    /**
     * There can be an edge case where custom numerical ids were added. Then if reverting to auto incremental ids
     * generated by this class after that, this class may generate a lot of ids already present.
     * We ensure here that if numerical ids are already present, we increment past the maximum.
     * @param id
     */
    private synchronized String checkAndAddIncrementalId(String id) {
        String definitiveId = prependUnderscoreIfNotAlready(id);
        logger.debug("check incremental id: {}", id);

        if(this.idSet.contains(definitiveId)) { // conflict detected
            logger.debug("conflict");
            // scan to find maximum
            long max = 0;
            for(String presentId: this.idSet) {
                long current = Long.parseLong(presentId.substring(1)); // removing leading underscore
                if(current > max) {
                    max = current;
                }
            }
            logger.debug("max id detected is: {}", max);

            // set counter past max number found
            idCounter = max + 1;

            // regenerate id
            definitiveId = prependUnderscoreIfNotAlready(createIncrementalID());

        }

        this.idSet.add(definitiveId);

        return definitiveId;
    }

    private synchronized String createIncrementalID() {
        return String.valueOf(idCounter++);
    }

    private String prependUnderscoreIfNotAlready(String s) {
        if(s.startsWith("_")) return s;
        else return "_" + s;
    }
}
